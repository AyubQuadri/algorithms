<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>k-nearest-neighbor interactive example</title>
        <!-- Piwik -->
        <script type="text/javascript">
          var _paq = _paq || [];
          _paq.push(['trackPageView']);
          _paq.push(['enableLinkTracking']);
          (function() {
            var u=(("https:" == document.location.protocol) ? "https" : "http") + "://martin-thoma.com/piwik//";
            _paq.push(['setTrackerUrl', u+'piwik.php']);
            _paq.push(['setSiteId', 1]);
            var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0]; g.type='text/javascript';
            g.defer=true; g.async=true; g.src=u+'piwik.js'; s.parentNode.insertBefore(g,s);
          })();
        </script>
        <!-- End Piwik Code -->
    </head>

    <body>
        <table>
            <tr>
                <td>display circle</td>
                <td><input type="checkbox" checked="checked" id="circle" onchange="updateBoard()"/></td>
                <td>k</td>
                <td><input type="number" step="1" value="2" id="k" min="1" onchange="updateBoard()"/></td>
                <td><a href="k-means.htm">clear board</a></td>
            </tr>
            <tr>
                <td>display voronoi</td>
                <td><input type="checkbox" id="voronoi" onchange="updateBoard()"/></td>
                <td>density</td>
                <td><input type="number" step="1" value="5" id="density" min="1" onchange="updateBoard()"/></td>
                <td>
                    <select id="algorithm">
                        <option>k-means</option>
                        <option>k-nearest-neighbor</option>
                    </select>
                </td>
            </tr>
        </table>
        <canvas id = "myCanvas"
                width = "512" height = "600" 
                style = "border:1px solid #000;"
        > </canvas>
    
    <script>
        function setCursorByID(id,cursorStyle) {
            var elem;
            if (document.getElementById &&
            (elem=document.getElementById(id)) ) {
                if (elem.style) elem.style.cursor=cursorStyle;
            }
        }

        function euklideanDist(p1, p2) {
            return Math.sqrt(
                          Math.pow(p1["x"]-p2["x"], 2) 
                        + Math.pow(p1["y"]-p2["y"], 2));
        }

        function getKMeansInfo(k, mouseX, mouseY) {
            var context = canvas.getContext('2d');
            var width = context.canvas.width;
            var height = context.canvas.height;

            // randomly choose cluster centers
            var clusterCenters = new Array(k);
            for (i=0; i<k; i++) {
                clusterCenters[i] = {
                    "x": Math.floor(Math.random()*width),
                    "y": Math.floor(Math.random()*height)
                };
            }

            for (iteration=0;iteration< 20;iteration++) {
                // for each object, check which cluster is nearest
                for (i=0; i<points.length; i++) {
                    var distMin = width+height+10;
                    var clusterMin = 0;
                    for(j=0; j<k; j++) {
                        var dist = euklideanDist(clusterCenters[j], points[i]);
                        if (dist < distMin) {
                            distMin = dist;
                            clusterMin = j
                        }
                    }
                    points[i]["cluster"] = clusterMin;
                }

                // calculate center of cluster
                var clusterSum = new Array(k);
                for (i=0; i<k; i++) {
                    clusterSum[i] = {"x":0, "y":0, "n":0};
                }
                for (i=0; i<points.length; i++) {
                    clusterSum[points[i]["cluster"]]["x"] += points[i]["cluster"]["x"];
                    clusterSum[points[i]["cluster"]]["y"] += points[i]["cluster"]["y"];
                    clusterSum[points[i]["cluster"]]["n"] += 1;
                }
                for (i=0; i<k; i++) {
                    clusterCenters[i] = {
                        "x":clusterSum[i]["x"]/clusterSum[i]["n"],
                        "y":clusterSum[i]["y"]/clusterSum[i]["n"]};
                }
            }

            // for mouse, check which cluster is nearest
            var mouseCoords = {"x": mouseX, "y": mouseY};
            var distMin = width+height+10;
            var clusterMin = 0;
            for(j=0; j<k; j++) {
                var dist = euklideanDist(clusterCenters[j], mouseCoords);
                if (dist < distMin) {
                    distMin = dist;
                    clusterMin = j
                }
            }

            return {"cluster":clusterMin, 
                    "radius":distMin};
        }

        /** Returns a dictionary with a cluster and a radius*/
        function getKNearestNeighbor(k, mouseX, mouseY) {
            if (points.length == 0) {
                return {"cluster":0, "radius":INITIAL_RADIUS};
            }

            var Distances = new Array();
            for(var i = 0; i < points.length; i++) {
                var mouseCoords = {"x": mouseX, "y": mouseY};
                var dist = euklideanDist(points[i], mouseCoords);
                Distances.push({"dist":dist, "cluster":points[i]["cluster"]});
            } 

            numberSort = function (a,b) {
                return a["dist"] - b["dist"];
            };

            Distances.sort(numberSort);
            if (Distances.length < k) {
                var clusterCount = new Array(2);
                clusterCount[0] = 0;
                clusterCount[1] = 0;
                for(var i = 0; i < Distances.length; i++) {
                    clusterCount[Distances[i]["cluster"]]++;
                }
                maxCluster = clusterCount[0] > clusterCount[1] ? 0 : 1;
                return {"cluster":maxCluster, "radius":Distances.slice(-1)[0]["dist"]};
            } else {
                var clusterCount = new Array(2);
                clusterCount[0] = 0;
                clusterCount[1] = 0;
                for(var i = 0; i < k; i++) {
                    clusterCount[Distances[i]["cluster"]]++;
                }
                maxCluster = clusterCount[0] >= clusterCount[1] ? 0 : 1;
                return {"cluster":maxCluster, 
                        "radius":Distances[k-1]["dist"]};
            }
        }

        function drawBoard(canvas, centerX, centerY, radius) {
            var context = canvas.getContext('2d');
            var k = parseInt(kElement.value);
            context.canvas.width  = window.innerWidth - 50;
            context.canvas.height = window.innerHeight - 90;
            context.clearRect(0, 0, canvas.width, canvas.height);

            if(document.getElementById("algorithm").value == "k-means") {
                var algorithm = getKMeansInfo;
            } else {
                var algorithm = getKNearestNeighbor;
            }

            if (document.getElementById("voronoi").checked) {
                var add = parseInt(document.getElementById("density").value);
                for (x=0; x < canvas.width; x+=add) {
                    for (y=0; y < canvas.height; y+=add) {
                        var kMeansInfo = getKNearestNeighbor(k, x, y);
                        if (kMeansInfo["cluster"] == 0) {
                            var r = 0;
                            var g = 255;
                            var b = 0;
                            var a = 150;
                        } else {
                            var r = 0;
                            var g = 0;
                            var b = 255;
                            var a = 150;
                        }
                        context.fillStyle = "rgba("+r+","+g+","+b+","+(a/255)+")";
                        context.fillRect(x, y, add/2, add/2);
                    }
                }
            }

            drawPoints(canvas);

            if (document.getElementById("circle").checked) {
                kMeansResult = getKNearestNeighbor(k, centerX, centerY);
                context.beginPath();
                context.arc(centerX, centerY, kMeansResult["radius"], 
                            0, 2 * Math.PI, false);
                if (kMeansResult["cluster"] == 0) {
                    context.fillStyle = 'rgba(100,255,100,0.5)';
                    context.strokeStyle = '#003300';
                } else {
                    context.fillStyle = 'rgba(100,100,255,0.5)';
                    context.strokeStyle = '#000033';
                }
                context.lineWidth = 2;
                context.fill();
                context.stroke();
            }
        }

        /** permanently add a point */
        function addPoint(event, canvas, centerX, centerY, radius) {
            if(event.ctrlKey)  {
                pointCluster = 1;
            } else {
                pointCluster = 0;
            }

            points.push({"x" : centerX,
                         "y" : centerY,
                         "radius"  : radius,
                         "cluster"   : pointCluster});
        }

        /** draw all permanently added points */
        function drawPoints(canvas) {
            for(var i = 0; i < points.length; i++) {
                context.beginPath();
                context.arc(points[i]["x"], 
                            points[i]["y"], 
                            points[i]["radius"], 
                            0, 2 * Math.PI, false);
                context.lineWidth = 1;
                context.strokeStyle = '#003300';
                if (points[i]["cluster"] == 0) {
                    context.fillStyle = 'green';
                } else {
                    context.fillStyle = 'blue';
                }
                context.fill();
                context.stroke();
            }
        }
      
        /** get the current position of the mouse */
        function getMousePos(canvas, evt) {
            var rect = canvas.getBoundingClientRect();
            return {
                x: evt.clientX - rect.left,
                y: evt.clientY - rect.top
            };
        }

        function updateBoard(){
            var canvas = document.getElementById("myCanvas");var canvas = document.getElementById("myCanvas");
            drawBoard(canvas, 0, 0, INITIAL_RADIUS);
        }
      
        /** global variables */
        var INITIAL_RADIUS = 20;
        var POINT_RADIUS = 5;
        var points = new Array();
        var canvas = document.getElementById("myCanvas");
        var kElement = document.getElementById("k");
        var context = canvas.getContext("2d");
        drawBoard(canvas, 0, 0, INITIAL_RADIUS);
        setCursorByID("myCanvas", "crosshair");

        /** event listeners */
        canvas.addEventListener('mousemove', 
            function(evt) {
                var mousePos = getMousePos(canvas, evt);
                drawBoard(canvas, mousePos.x, mousePos.y, INITIAL_RADIUS);
            }, false);

        canvas.addEventListener("mousedown", 
            function(event) {
                var mousePos = getMousePos(canvas, event);
                addPoint(event, canvas, mousePos.x, mousePos.y, POINT_RADIUS);
            }, false);
    </script>
</body>
</html>
